
read.byte_reader("B0 B1 B2 B3", "B4 B5 B6 B7");
read.wrap(32);
read.reset_start_time;

<c_script>

/* Context switch markers in the trace. */
#define RVS_TIMER_ENTRY    0xfffffff9     /* timer interrupt entry */
#define RVS_TIMER_EXIT     0xfffffff8     /* timer interrupt exit */
#define RVS_SYS_ENTRY      0xfffffff7     /* syscall entry */
#define RVS_SYS_EXIT       0xfffffff6     /* syscall exit */
#define RVS_IRQ_ENTRY      0xfffffff5     /* interrupt entry */
#define RVS_IRQ_EXIT       0xfffffff4     /* interrupt exit */
#define RVS_SWITCH_FROM    0xfffffff3     /* task suspended */
#define RVS_SWITCH_TO      0xfffffff2     /* task resumed */
#define RVS_BEGIN_WRITE    0xfffffff1     /* userspace: librvs began writing trace to disk */
#define RVS_END_WRITE      0xfffffff0     /* userspace: librvs finished writing trace to disk */

int interrupted = 0;
unsigned long long skip_time = 0;
unsigned long long last_valid_time = 0;

void filter_block (t_trace_elts trace, unsigned int * last)
{
	int i, j;
	
	for (i = j = 0; i < (*last); i++) {
      switch (trace[i].i) {
         case RVS_SWITCH_FROM:
         case RVS_BEGIN_WRITE:
         case RVS_TIMER_ENTRY:
         case RVS_SYS_ENTRY:
         case RVS_IRQ_ENTRY:
         case RVS_SWITCH_TO:
         case RVS_END_WRITE:
         case RVS_TIMER_EXIT:
         case RVS_SYS_EXIT:
         case RVS_IRQ_EXIT:
            interrupted = 1;
            break;
         default:
            if (interrupted) {
               skip_time += trace[i].t - last_valid_time;
               interrupted = 0;
            }
            last_valid_time = trace[i].t;
            trace[j] = trace[i];
            trace[j].t -= skip_time;
            trace[j].wt -= skip_time;
            j++;
            break;
      }
   }
   (*last) = j;
}

</c_script>
