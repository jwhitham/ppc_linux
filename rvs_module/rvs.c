/*
 *  RVS Tracing API
 *
 *  Author: Jack Whitham (jwhitham@rapitasystems.com)
 *
 *  RVS trace point module. Implements /dev/rvs, and enables
 *  access to the trace buffer implemented in arch/powerpc/kernel/
 *
 *  Copyright (C) 2016 Rapita Systems Ltd.
 *
 */
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/list.h>
#include <linux/rcupdate.h>
#include <linux/sched.h>
#include <linux/spinlock.h>
#include <linux/uaccess.h>
#include <linux/miscdevice.h>
#include <linux/slab.h>
#include <linux/mm.h>
#include <linux/io.h>
#include <linux/pm.h>
#include <linux/tracepoint.h>
#include <trace/events/syscalls.h>
#include <trace/events/fault.h>
#include <trace/events/mathemu.h>
#include <trace/syscall.h>
#include <asm/pgtable.h>
#include <asm/trace.h>
#include <asm/siginfo.h>

#include <linux/trace_rvs.h>

#include "rvs.h"

/* Markers generated by tracepoints and preempt_notifiers interface */
#define RVS_MATHEMU_ENTRY  0xfffffffd     /* floating point emulator activated */
#define RVS_PFAULT_ENTRY   0xfffffffb     /* page fault (handled in C) */
#define RVS_TIMER_ENTRY    0xfffffff9     /* timer tick (handled in C) */
#define RVS_SYS_ENTRY      0xfffffff7     /* system call */
#define RVS_IRQ_ENTRY      0xfffffff5     /* interrupt (handled in C) */
#define RVS_SWITCH_FROM    0xfffffff3     /* task suspended */
#define RVS_SWITCH_TO      0xfffffff2     /* task resumed */

/* Other markers are generated in assembly code, and include: 
 * 0xffffff83  Data storage exception
 * 0xffffff84  Instruction storage exception
 * 0xffffff85  Interrupt
 * 0xffffff86  Alignment error
 * 0xffffff89  Timer tick
 * 0xffffff8c  System call
 * 0xffffffee  SPE is activated for a task (first SPE instruction)
 * 0xffffffef  TLB updated (n.b. not the same as "page fault")
 */

/* Global state */
typedef enum {
   MODULE_UNLOADED = 0,
   MODULE_LOADED,
   DEVICE_OPEN,
   TRACE_ENABLED_TASK_SUSPENDED,
   TRACE_ENABLED_TASK_RUNNING,
   TRACE_DOWNLOAD,
} rvs_state_t;

static spinlock_t lock;  /* Data structure lock (for state) */
static rvs_state_t state = MODULE_UNLOADED;
static int overflow_signal_sent = 0;

/* valid if state >= DEVICE_OPEN: */
static pid_t rvs_task_pid = 0;
static uid_t rvs_task_uid = 0;
struct pid * rvs_signal_pid = NULL;

/* valid if state >= TRACE_ENABLED_TASK_SUSPENDED: */
static struct preempt_notifier notifier;  

struct rvs_task {
   unsigned dummy;
};

static struct rvs_task dummy_ptr;


static void send_overflow_signal (void)
{
   int rc;

   spin_lock (&lock);
   if ((!overflow_signal_sent) 
   && ((state == TRACE_ENABLED_TASK_RUNNING)
         || (state == TRACE_ENABLED_TASK_SUSPENDED))) {

      /* Send signal to indicate imminent overflow */
      spin_unlock (&lock);
      rc = kill_pid (rvs_signal_pid, SIG_RVS_IMMINENT_OVERFLOW, 0);
      spin_lock (&lock);
      if (rc == 0) {
         /* Sending the signal may fail if the system is busy. */
         overflow_signal_sent = 1;
      }
   }
   spin_unlock (&lock);
}

static inline void detect_overflow_imminent (int overflow)
{
   if (!overflow) {
      return;
   }
   if (overflow_signal_sent) {
      return;
   }
   send_overflow_signal ();
}

static void rvs_sched_in(struct preempt_notifier *pn, int cpu)
{
   int overflow = 0;
   spin_lock (&lock);
   if (state == TRACE_ENABLED_TASK_SUSPENDED) {
      state = TRACE_ENABLED_TASK_RUNNING;
      trace_rvs_start ();
      overflow = trace_rvs_ipoint (RVS_SWITCH_TO);
   }
   spin_unlock (&lock);
   detect_overflow_imminent (overflow);
}

static void rvs_sched_out(struct preempt_notifier *pn,
           struct task_struct *next)
{
   int overflow = 0;
   spin_lock (&lock);
   if (state == TRACE_ENABLED_TASK_RUNNING) {
      state = TRACE_ENABLED_TASK_SUSPENDED;
      /* task will be suspended so there is no point looking for
       * the overflow condition now, hence (void) */
      overflow = trace_rvs_ipoint (RVS_SWITCH_FROM);
      trace_rvs_stop ();
   }
   spin_unlock (&lock);
   detect_overflow_imminent (overflow);
}

static void rvs_timer_entry (void *data, struct pt_regs *regs)
{
   detect_overflow_imminent (trace_rvs_ipoint (RVS_TIMER_ENTRY));
}

static void rvs_irq_entry (void *data, struct pt_regs *regs)
{
   detect_overflow_imminent (trace_rvs_ipoint (RVS_IRQ_ENTRY));
}

static void rvs_sys_entry (void *data, struct pt_regs *regs, long id)
{
   detect_overflow_imminent (trace_rvs_ipoint (RVS_SYS_ENTRY));
}

static void rvs_page_fault_entry (void *data, struct pt_regs *regs, unsigned long address, int write_access)
{
   detect_overflow_imminent (trace_rvs_ipoint (RVS_PFAULT_ENTRY));
}

static void rvs_mathemu_entry (void *data, struct pt_regs *regs, unsigned long address, unsigned long insn)
{
   detect_overflow_imminent (trace_rvs_ipoint (RVS_MATHEMU_ENTRY));
}

static struct preempt_ops rvs_preempt_ops = {
   .sched_in = rvs_sched_in,
   .sched_out = rvs_sched_out,
};

static void rvs_init_notifiers (void)
{
   preempt_notifier_register(&notifier);
   preempt_disable();
   register_trace_timer_interrupt_entry(rvs_timer_entry, NULL);
   register_trace_irq_entry(rvs_irq_entry, NULL);
   register_trace_sys_enter(rvs_sys_entry, NULL);
   register_trace_page_fault_entry(rvs_page_fault_entry, NULL);
   register_trace_mathemu_entry(rvs_mathemu_entry, NULL);
   preempt_enable();
}

static void rvs_clear_notifiers (void)
{
   preempt_notifier_unregister(&notifier);
   preempt_disable();
   unregister_trace_timer_interrupt_entry(rvs_timer_entry, NULL);
   unregister_trace_irq_entry(rvs_irq_entry, NULL);
   unregister_trace_sys_enter(rvs_sys_entry, NULL);
   unregister_trace_page_fault_entry(rvs_page_fault_entry, NULL);
   unregister_trace_mathemu_entry(rvs_mathemu_entry, NULL);
   tracepoint_synchronize_unregister();
   preempt_enable();
}

/* Change to DEVICE_OPEN state, if tracing is in progress.
 * Used by rvs_disable
 * Also used by rvs_release if the user closes the device while tracing,
 * and used by rvs_read if the user tries to read without disabling
 * tracing first. */
static void rvs_goto_device_open (void)
{
   switch (state) {
      case TRACE_ENABLED_TASK_RUNNING:
         trace_rvs_stop ();
         state = TRACE_ENABLED_TASK_SUSPENDED;
         /* fall through */
      case TRACE_ENABLED_TASK_SUSPENDED:
         rvs_clear_notifiers ();
         state = DEVICE_OPEN;
         /* fall through */
      case DEVICE_OPEN:
         break;
      case TRACE_DOWNLOAD:
         /* Trace is being downloaded right now, it's up to
          * the caller to decide what to do in this situation */
         break;
      case MODULE_UNLOADED: BUG (); break;
      case MODULE_LOADED: BUG (); break;
      default: BUG (); break;
   }
}

static long rvs_ioctl_get_version(struct file *filp, void __user *argp)
{
   __u32 version = RVS_API_VERSION;

   if (copy_to_user(argp, &version, sizeof(__u32)))
      return -EFAULT;
   return 0;
}

static long rvs_ioctl_reset(struct file *filp, void __user *argp)
{
   struct rvs_task *taskp = filp->private_data;
   int rc = 0;

   BUG_ON (taskp != &dummy_ptr);

   if (argp) {
      return -EINVAL;
   }

   spin_lock (&lock);
   switch (state) {
      case TRACE_DOWNLOAD:
         printk (KERN_ERR "rvs: attempted to reset RVS device while reading from it.\n");
         rc = -EBUSY;
         break;
      case MODULE_UNLOADED: BUG (); break;
      case MODULE_LOADED: BUG (); break;
      case TRACE_ENABLED_TASK_SUSPENDED:
      case TRACE_ENABLED_TASK_RUNNING:
         printk (KERN_ERR "rvs: attempted to reset RVS device while tracing.\n");
         rc = -EBUSY;
         break;
      case DEVICE_OPEN:
         trace_rvs_reset ();
         overflow_signal_sent = 0;
         rc = 0;
         break;
      default: BUG (); break;
   }
   spin_unlock (&lock);
   return rc;
}

static long rvs_enable(struct file *filp, void __user *argp)
{
   struct rvs_task *taskp = filp->private_data;
   int rc = 0;

   BUG_ON (taskp != &dummy_ptr);

   if (argp) {
      return -EINVAL;
   }

   spin_lock (&lock);
   switch (state) {
      case TRACE_DOWNLOAD:
         printk (KERN_ERR "rvs: attempted to enable RVS device while reading from it.\n");
         rc = -EBUSY;
         break;
      case MODULE_UNLOADED: BUG (); break;
      case MODULE_LOADED: BUG (); break;
      case TRACE_ENABLED_TASK_SUSPENDED:
      case TRACE_ENABLED_TASK_RUNNING:
         printk (KERN_ERR "rvs: attempted to enable RVS device twice.\n");
         rc = -EBUSY;
         break;
      case DEVICE_OPEN:
         state = TRACE_ENABLED_TASK_RUNNING;
         rvs_init_notifiers ();
         trace_rvs_start ();
         rc = 0;
         break;
      default: BUG (); break;
   }
   spin_unlock (&lock);
   return rc;
}

static long rvs_disable(struct file *filp, void __user *argp)
{
   struct rvs_task *taskp = filp->private_data;
   int rc = 0;

   BUG_ON (taskp != &dummy_ptr);

   if (argp) {
      return -EINVAL;
   }

   spin_lock (&lock);
   if (state == TRACE_DOWNLOAD) {
      printk (KERN_ERR "rvs: attempted to disable RVS device while reading.\n");
      rc = -EBUSY;
   } else {
      rvs_goto_device_open ();
      BUG_ON (state != DEVICE_OPEN);
   }
   spin_unlock (&lock);
   return rc;
}

static ssize_t rvs_read(struct file *filp, char __user *buf,
         size_t count, loff_t *lpos)
{
   struct rvs_task *taskp = filp->private_data;
   ssize_t rc = 0;

   BUG_ON (taskp != &dummy_ptr);

   /* Drop to DEVICE_OPEN state before permitting read */
   spin_lock (&lock);
   rvs_goto_device_open ();
   if (state == TRACE_DOWNLOAD) {
      printk (KERN_ERR "rvs: attempted to read from RVS device concurrently.\n");
      rc = -EBUSY;
      goto err;
   }
   BUG_ON (state != DEVICE_OPEN);

   /* We expect current to be the owner of the trace.  This could
    * happen for example if a file descriptor for the tracer is
    * inherited from a parent process. */
   if (task_pid_vnr (current) != rvs_task_pid) {
      printk(KERN_INFO "rvs: thread data for %u read from "
            "thread %u\n", 
            rvs_task_pid,
            task_pid_vnr(current));
      rc = -EINVAL;
      goto err;
   }
   /* Parameter test */
   if (*lpos != 0) {
      printk(KERN_INFO "rvs: lpos != 0\n");
      rc = -EINVAL;
      goto err;
   }

   state = TRACE_DOWNLOAD;
   trace_rvs_stop (); /* defensive */
   spin_unlock (&lock);

   rc = trace_rvs_download ((void __user *) buf, count);

   spin_lock (&lock);
   BUG_ON (state != TRACE_DOWNLOAD);
   state = DEVICE_OPEN;
   if (rc >= 0) {
      overflow_signal_sent = 0;
   }
err:
   spin_unlock (&lock);
   return rc;
}

static int rvs_mmap(struct file *file, struct vm_area_struct *vma)
{
   return -EINVAL;
}

static int rvs_open(struct inode *inode, struct file *filp)
{
   int rc = -EINVAL;

   spin_lock (&lock);
   switch (state) {
      case MODULE_UNLOADED: BUG (); break;
      case MODULE_LOADED:
         state = DEVICE_OPEN;
         rvs_signal_pid = task_pid (current);
         rvs_task_pid = task_pid_vnr (current);
         rvs_task_uid = from_kuid_munged (current_user_ns(), current_uid());
         filp->private_data = &dummy_ptr;
         trace_rvs_stop (); /* defensive */
         trace_rvs_reset (); /* defensive */
         overflow_signal_sent = 0;
         rc = 0;
         break;
      case TRACE_ENABLED_TASK_RUNNING:
      case TRACE_ENABLED_TASK_SUSPENDED:
      case TRACE_DOWNLOAD:
      case DEVICE_OPEN:
         printk (KERN_ERR "rvs: attempted to open RVS device twice.\n");
         rc = -EBUSY;
         break;
      default: BUG (); break;
   }
   spin_unlock (&lock);

   return rc;
}

static int rvs_release(struct inode *inode, struct file *filp)
{
   struct rvs_task *taskp = filp->private_data;
   int rc = 0;

   BUG_ON (taskp != &dummy_ptr);
   spin_lock (&lock);
   rvs_goto_device_open ();
   switch (state) {
      case MODULE_UNLOADED: BUG (); break;
      case TRACE_ENABLED_TASK_SUSPENDED: BUG (); break;
      case TRACE_ENABLED_TASK_RUNNING: BUG (); break;
      case MODULE_LOADED: BUG (); break;
      case TRACE_DOWNLOAD:
         printk (KERN_ERR "rvs: attempted to close RVS device while reading "
            "trace from it: close attempt failed.\n");
         rc = -EBUSY;
         break;
      case DEVICE_OPEN:
         trace_rvs_reset ();
         state = MODULE_LOADED;
         rvs_task_pid = 0;
         rvs_task_uid = 0;
         rvs_signal_pid = NULL;
         overflow_signal_sent = 0;
         break;
      default: BUG (); break;
   }
   spin_unlock (&lock);

   return rc;
}

static long rvs_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg)
{
   void __user *argp = (void __user *)arg;
   long r = -EINVAL;

   switch (ioctl) {
   case RVS_GET_VERSION:
      r = rvs_ioctl_get_version(filp, argp);
      break;
   case RVS_RESET:
      r = rvs_ioctl_reset(filp, argp);
      break;
   case RVS_ENABLE:
      r = rvs_enable(filp, argp);
      break;
   case RVS_DISABLE:
      r = rvs_disable(filp, argp);
      break;
   default:
      break;
   }
   return r;
}

/* Character device interface. */
static struct file_operations rvs_chardev_ops = {
   .owner = THIS_MODULE,
   .read = rvs_read,
   .open = rvs_open,
   .mmap = rvs_mmap,
   .release = rvs_release,
   .unlocked_ioctl = rvs_ioctl,
   .llseek = no_llseek,
};

static struct miscdevice rvs_dev = {
   MISC_DYNAMIC_MINOR,
   "rvs",
   &rvs_chardev_ops,
};

static int __init rvs_init(void)
{
   int r;

   printk(KERN_INFO "rvs: loading trace module, API version %d\n", RVS_API_VERSION);

   if (state != MODULE_UNLOADED) {
      r = -EINVAL;
      printk(KERN_ERR "rvs: module state unexpected\n");
      goto out;
   }

   r = misc_register(&rvs_dev);
   if (r) {
      printk(KERN_ERR "rvs: failed registering character device\n");
      goto out;
   }

   preempt_notifier_init (&notifier, &rvs_preempt_ops);
   spin_lock_init(&lock);
   state = MODULE_LOADED;
   overflow_signal_sent = 0;
   trace_rvs_stop (); /* defensive */
   trace_rvs_reset (); /* defensive */
out:
   return r;
}

static void __exit rvs_exit(void)
{
   printk(KERN_INFO "rvs: unloading trace module\n");
   BUG_ON (state != MODULE_LOADED);
   state = MODULE_UNLOADED;
   trace_rvs_stop (); /* defensive */
   trace_rvs_reset (); /* defensive */
   misc_deregister(&rvs_dev);
}

module_init(rvs_init);
module_exit(rvs_exit);

MODULE_LICENSE("GPL");
